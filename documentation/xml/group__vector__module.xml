<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.20" xml:lang="en-US">
  <compounddef id="group__vector__module" kind="group">
    <compoundname>vector_module</compoundname>
    <title>Vector</title>
      <sectiondef kind="user-defined">
      <header>Comparison</header>
      <memberdef kind="function" id="group__vector__module_1ga62199ee08af9e8d95c43db26508da544" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>_Bool</type>
        <definition>_Bool vector_eq</definition>
        <argsstring>(vector_c va, vector_c vb, _Bool(*eq)(const void *a, const void *b))</argsstring>
        <name>vector_eq</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>_Bool(*)(const void *a, const void *b)</type>
          <declname>eq</declname>
        </param>
        <briefdescription>
<para>Return whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Here &quot;equivalent&quot; means that both of <emphasis>va</emphasis> and <emphasis>vb</emphasis> are <computeroutput>NULL</computeroutput>, or neither <emphasis>va</emphasis> or <emphasis>vb</emphasis> is <computeroutput>NULL</computeroutput> and:</para>
<para><itemizedlist>
<listitem><para><emphasis>va</emphasis> and <emphasis>vb</emphasis> have the same length, and</para>
</listitem><listitem><para><emphasis>eq</emphasis> returns <computeroutput>true</computeroutput> when called on each element in <emphasis>va</emphasis> and the element at the same index in <emphasis>vb</emphasis> </para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>va</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vb</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eq</parametername>
</parameternamelist>
<parameterdescription>
<para>the equality function that will be used to decide whether an element in <emphasis>va</emphasis> is equivalent to an element in <emphasis>vb</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="36" column="7" bodyfile="header/vector/comparison.h" bodystart="36" bodyend="36"/>
        <references refid="group__vector__module_1gaf3fe34e28652403f7753d191f93c1fc4" compoundref="header_2vector_2comparison_8c" startline="22" endline="29">vector_eq_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gaf3fe34e28652403f7753d191f93c1fc4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>_Bool</type>
        <definition>_Bool vector_eq_z</definition>
        <argsstring>(vector_c va, vector_c vb, _Bool(*eq)(const void *a, const void *b), size_t za, size_t zb)</argsstring>
        <name>vector_eq_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>_Bool(*)(const void *a, const void *b)</type>
          <declname>eq</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>za</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Return whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>Here &quot;equivalent&quot; means that both of <emphasis>va</emphasis> and <emphasis>vb</emphasis> are <computeroutput>NULL</computeroutput>, or neither <emphasis>va</emphasis> or <emphasis>vb</emphasis> is <computeroutput>NULL</computeroutput> and:</para>
<para><itemizedlist>
<listitem><para><emphasis>va</emphasis> and <emphasis>vb</emphasis> have the same length, and</para>
</listitem><listitem><para><emphasis>eq</emphasis> returns <computeroutput>true</computeroutput> when called on each element in <emphasis>va</emphasis> and the element at the same index in <emphasis>vb</emphasis> </para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>va</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vb</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eq</parametername>
</parameternamelist>
<parameterdescription>
<para>the equality function that will be used to decide whether an element in <emphasis>va</emphasis> is equivalent to an element in <emphasis>vb</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>za</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of <emphasis>va</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of <emphasis>vb</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="57" column="14" bodyfile="header/vector/comparison.c" bodystart="22" bodyend="29" declfile="header/vector/comparison.h" declline="57" declcolumn="14"/>
        <references refid="group__vector__module_1ga93613d2838fd60a1f478f145a7d766db" compoundref="header_2vector_2comparison_8c" startline="31" endline="52">vector_eq_with_z</references>
        <referencedby refid="group__vector__module_1ga62199ee08af9e8d95c43db26508da544" compoundref="comparison_8h" startline="36" endline="36">vector_eq</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga0b9271c52ecfc92c465a059ce3cc4178" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>_Bool</type>
        <definition>_Bool vector_eq_with</definition>
        <argsstring>(vector_c va, vector_c vb, _Bool(*eq)(const void *a, const void *b, void *data), void *data)</argsstring>
        <name>vector_eq_with</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>_Bool(*)(const void *a, const void *b, void *data)</type>
          <declname>eq</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Return whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis> with contextual information. </para>
        </briefdescription>
        <detaileddescription>
<para>Here &quot;equivalent&quot; means that both of <emphasis>va</emphasis> and <emphasis>vb</emphasis> are <computeroutput>NULL</computeroutput>, or neither <emphasis>va</emphasis> or <emphasis>vb</emphasis> is <computeroutput>NULL</computeroutput> and:</para>
<para><itemizedlist>
<listitem><para><emphasis>va</emphasis> and <emphasis>vb</emphasis> have the same length, and</para>
</listitem><listitem><para><emphasis>eq</emphasis> returns <computeroutput>true</computeroutput> when called on each element in <emphasis>va</emphasis> and the element at the same index in <emphasis>vb</emphasis> </para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>va</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vb</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eq</parametername>
</parameternamelist>
<parameterdescription>
<para>the equality function that will be used to decide whether an element in <emphasis>va</emphasis> is equivalent to an element in <emphasis>vb</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>contextual information to pass as the last argument to <emphasis>eq</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="88" column="7" bodyfile="header/vector/comparison.h" bodystart="88" bodyend="88"/>
        <references refid="group__vector__module_1ga93613d2838fd60a1f478f145a7d766db" compoundref="header_2vector_2comparison_8c" startline="31" endline="52">vector_eq_with_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga93613d2838fd60a1f478f145a7d766db" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>_Bool</type>
        <definition>_Bool vector_eq_with_z</definition>
        <argsstring>(vector_c va, vector_c vb, _Bool(*eq)(const void *a, const void *b, void *data), void *data, size_t za, size_t zb)</argsstring>
        <name>vector_eq_with_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>_Bool(*)(const void *a, const void *b, void *data)</type>
          <declname>eq</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>za</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
<para>Return whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis> with contextual information. </para>
        </briefdescription>
        <detaileddescription>
<para>Here &quot;equivalent&quot; means that both of <emphasis>va</emphasis> and <emphasis>vb</emphasis> are <computeroutput>NULL</computeroutput>, or neither <emphasis>va</emphasis> or <emphasis>vb</emphasis> is <computeroutput>NULL</computeroutput> and:</para>
<para><itemizedlist>
<listitem><para><emphasis>va</emphasis> and <emphasis>vb</emphasis> have the same length, and</para>
</listitem><listitem><para><emphasis>eq</emphasis> returns <computeroutput>true</computeroutput> when called on each element in <emphasis>va</emphasis> and the element at the same index in <emphasis>vb</emphasis> </para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>va</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vb</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eq</parametername>
</parameternamelist>
<parameterdescription>
<para>the equality function that will be used to decide whether an element in <emphasis>va</emphasis> is equivalent to an element in <emphasis>vb</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>contextual information to pass as the last argument to <emphasis>eq</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>za</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of <emphasis>va</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zb</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of <emphasis>vb</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether vector <emphasis>va</emphasis> is equivalent to vector <emphasis>vb</emphasis> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="111" column="14" bodyfile="header/vector/comparison.c" bodystart="31" bodyend="52" declfile="header/vector/comparison.h" declline="111" declcolumn="14"/>
        <references refid="access_8h_1a3d34a65010e7b668473c10be6f6f72e1" compoundref="access_8h" startline="45" endline="45">vector_at</references>
        <references refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" compoundref="common_8h" startline="95" endline="97">vector_length</references>
        <referencedby refid="group__vector__module_1ga0b9271c52ecfc92c465a059ce3cc4178" compoundref="comparison_8h" startline="88" endline="88">vector_eq_with</referencedby>
        <referencedby refid="group__vector__module_1gaf3fe34e28652403f7753d191f93c1fc4" compoundref="header_2vector_2comparison_8c" startline="22" endline="29">vector_eq_z</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gaa94a318aa532b624fedc33bb2a55b1f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int vector_cmp</definition>
        <argsstring>(vector_c va, vector_c vb, int(*cmp)(const void *a, const void *b))</argsstring>
        <name>vector_cmp</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b)</type>
          <declname>cmp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="123" column="5" bodyfile="header/vector/comparison.h" bodystart="123" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gacca4dbb6b85cf7e230bfd7840c30d978" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int vector_cmp_z</definition>
        <argsstring>(vector_c va, vector_c vb, int(*cmp)(const void *a, const void *b), size_t za, size_t zb)</argsstring>
        <name>vector_cmp_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b)</type>
          <declname>cmp</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>za</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="126" column="12" declfile="header/vector/comparison.h" declline="126" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga77c08967631de17b4d74267ebba98e1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int vector_cmp_with</definition>
        <argsstring>(vector_c va, vector_c vb, int(*cmp)(const void *a, const void *b, void *data), void *data)</argsstring>
        <name>vector_cmp_with</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b, void *data)</type>
          <declname>cmp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="138" column="5" bodyfile="header/vector/comparison.h" bodystart="138" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga313ed5324d29aeeed519342b199a4537" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int vector_cmp_with_z</definition>
        <argsstring>(vector_c va, vector_c vb, int(*cmp)(const void *a, const void *b, void *data), void *data, size_t za, size_t zb)</argsstring>
        <name>vector_cmp_with_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>va</declname>
        </param>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vb</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b, void *data)</type>
          <declname>cmp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>za</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>zb</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/comparison.h" line="141" column="12" declfile="header/vector/comparison.h" declline="141" declcolumn="12"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Search</header>
      <memberdef kind="function" id="group__vector__module_1ga6179808aafb668e4287de4d030173ba9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_find</definition>
        <argsstring>(vector_c vector, bool(*eqf)(const void *elmt, const void *data), const void *data)</argsstring>
        <name>vector_find</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>bool(*)(const void *elmt, const void *data)</type>
          <declname>eqf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Find the first element in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This will return the index of the first element in the <emphasis>vector</emphasis> for which the expression <computeroutput>eqf(elmt, data)</computeroutput> is <computeroutput>true</computeroutput> where <emphasis>elmt</emphasis> is the location of an element in the <emphasis>vector</emphasis>.</para>
<para>If no such element is in the <emphasis>vector</emphasis> then this will return <computeroutput>SIZE_MAX</computeroutput>. Note that the largest possible index into an array of any type is <computeroutput>SIZE_MAX - 1</computeroutput> so <computeroutput>SIZE_MAX</computeroutput> is an unambiguous indication that no such element is in the <emphasis>vector</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eqf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>additional data to pass to <emphasis>eqf</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="41" column="8" bodyfile="header/vector/search.h" bodystart="41" bodyend="41"/>
        <references refid="group__vector__module_1gaa886a904776e7c0cc6bdec4eefacd04a" compoundref="header_2vector_2search_8c" startline="19" endline="25">vector_find_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gaa886a904776e7c0cc6bdec4eefacd04a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_find_z</definition>
        <argsstring>(vector_c vector, bool(*eqf)(const void *elmt, const void *data), const void *data, size_t z)</argsstring>
        <name>vector_find_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>bool(*)(const void *elmt, const void *data)</type>
          <declname>eqf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Find the first element in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This will return the index of the first element in the <emphasis>vector</emphasis> for which the expression <computeroutput>eqf(elmt, data)</computeroutput> is <computeroutput>true</computeroutput> where <emphasis>elmt</emphasis> is the location of an element in the <emphasis>vector</emphasis>.</para>
<para>If no such element is in the <emphasis>vector</emphasis> then this will return <computeroutput>SIZE_MAX</computeroutput>. Note that the largest possible index into an array of any type is <computeroutput>SIZE_MAX - 1</computeroutput> so <computeroutput>SIZE_MAX</computeroutput> is an unambiguous indication that no such element is in the <emphasis>vector</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eqf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>additional data to pass to <emphasis>eqf</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of the <emphasis>vector</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="61" column="15" bodyfile="header/vector/search.c" bodystart="19" bodyend="25" declfile="header/vector/search.h" declline="61" declcolumn="15"/>
        <references refid="group__vector__module_1gac688a8f438657eb30088adccc3a14bb6" compoundref="header_2vector_2search_8c" startline="27" endline="38">vector_find_next_z</references>
        <referencedby refid="group__vector__module_1ga6179808aafb668e4287de4d030173ba9" compoundref="search_8h" startline="41" endline="41">vector_find</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gaf1add13716135b33cf3e21f679f7ba17" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_find_next</definition>
        <argsstring>(vector_c vector, size_t i, bool(*eqf)(const void *elmt, const void *data), const void *data)</argsstring>
        <name>vector_find_next</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <param>
          <type>bool(*)(const void *elmt, const void *data)</type>
          <declname>eqf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Find the first element at or after index <emphasis>i</emphasis> in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This will return the index of the first element in the <emphasis>vector</emphasis> at or after index <emphasis>i</emphasis> for which the expression <computeroutput>eqf(elmt, data)</computeroutput> is <computeroutput>true</computeroutput> where <emphasis>elmt</emphasis> is the location of an element in the <emphasis>vector</emphasis>. Index <emphasis>i</emphasis> is <bold>inclusive</bold> so if the element at that index is equal to <emphasis>data</emphasis>, then <emphasis>i</emphasis> itself will be returned.</para>
<para>To iterate through all elements in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis> do: <programlisting filename=".c"><codeline><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1ga6179808aafb668e4287de4d030173ba9" kindref="member">vector_find</ref>(vector,<sp/>eqf,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(i<sp/>&lt;<sp/><ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">vector_length</ref>(vector))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1gaf1add13716135b33cf3e21f679f7ba17" kindref="member">vector_find_next</ref>(vector,<sp/>i<sp/>+<sp/>1,<sp/>eqf,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If no such element is in the <emphasis>vector</emphasis> at or after index <emphasis>i</emphasis>, then this will return <computeroutput>SIZE_MAX</computeroutput>. Note that the largest possible index into an array of any type is <computeroutput>SIZE_MAX - 1</computeroutput> so <computeroutput>SIZE_MAX</computeroutput> is an unambiguous indication that no such element is in the <emphasis>vector</emphasis>.</para>
<para>If <emphasis>i</emphasis> is neither an index in the <emphasis>vector</emphasis> or its <ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">length</ref> then the behavior is undefined. As a special case if <emphasis>i</emphasis> is the <emphasis>vector</emphasis>&apos;s length, then will return <computeroutput>SIZE_MAX</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>the lowest index in the <emphasis>vector</emphasis> to consider </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eqf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>additional data to pass to <emphasis>eqf</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="107" column="8" bodyfile="header/vector/search.h" bodystart="107" bodyend="107"/>
        <references refid="group__vector__module_1gac688a8f438657eb30088adccc3a14bb6" compoundref="header_2vector_2search_8c" startline="27" endline="38">vector_find_next_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gac688a8f438657eb30088adccc3a14bb6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_find_next_z</definition>
        <argsstring>(vector_c vector, size_t i, bool(*eqf)(const void *elmt, const void *data), const void *data, size_t z)</argsstring>
        <name>vector_find_next_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <param>
          <type>bool(*)(const void *elmt, const void *data)</type>
          <declname>eqf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Find the first element at or after index <emphasis>i</emphasis> in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This will return the index of the first element in the <emphasis>vector</emphasis> at or after index <emphasis>i</emphasis> for which the expression <computeroutput>eqf(elmt, data)</computeroutput> is <computeroutput>true</computeroutput> where <emphasis>elmt</emphasis> is the location of an element in the <emphasis>vector</emphasis>. Index <emphasis>i</emphasis> is <bold>inclusive</bold> so if the element at that index is equal to <emphasis>data</emphasis>, then <emphasis>i</emphasis> itself will be returned.</para>
<para>To iterate through all elements in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis> do: <programlisting filename=".c"><codeline><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1gaa886a904776e7c0cc6bdec4eefacd04a" kindref="member">vector_find_z</ref>(vector,<sp/>eqf,<sp/>data,<sp/>z);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(i<sp/>&lt;<sp/><ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">vector_length</ref>(vector))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1gac688a8f438657eb30088adccc3a14bb6" kindref="member">vector_find_next_z</ref>(vector,<sp/>i<sp/>+<sp/>1,<sp/>eqf,<sp/>data,<sp/>z);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If no such element is in the <emphasis>vector</emphasis> at or after index <emphasis>i</emphasis>, then this will return <computeroutput>SIZE_MAX</computeroutput>. Note that the largest possible index into an array of any type is <computeroutput>SIZE_MAX - 1</computeroutput> so <computeroutput>SIZE_MAX</computeroutput> is an unambiguous indication that no such element is in the <emphasis>vector</emphasis>.</para>
<para>If <emphasis>i</emphasis> is neither an index in the <emphasis>vector</emphasis> or its <ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">length</ref> then the behavior is undefined. As a special case if <emphasis>i</emphasis> is the <emphasis>vector</emphasis>&apos;s length, then will return <computeroutput>SIZE_MAX</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>the lowest index in the <emphasis>vector</emphasis> to consider </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eqf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>additional data to pass to <emphasis>eqf</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of the <emphasis>vector</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="145" column="15" bodyfile="header/vector/search.c" bodystart="27" bodyend="38" declfile="header/vector/search.h" declline="145" declcolumn="15"/>
        <references refid="access_8h_1a3d34a65010e7b668473c10be6f6f72e1" compoundref="access_8h" startline="45" endline="45">vector_at</references>
        <references refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" compoundref="common_8h" startline="95" endline="97">vector_length</references>
        <referencedby refid="group__vector__module_1gaf1add13716135b33cf3e21f679f7ba17" compoundref="search_8h" startline="107" endline="107">vector_find_next</referencedby>
        <referencedby refid="group__vector__module_1gaa886a904776e7c0cc6bdec4eefacd04a" compoundref="header_2vector_2search_8c" startline="19" endline="25">vector_find_z</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga99fa8624e711c5592b80bf2a4b40952d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_find_last</definition>
        <argsstring>(vector_c vector, size_t i, bool(*eqf)(const void *elmt, const void *data), const void *data)</argsstring>
        <name>vector_find_last</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <param>
          <type>bool(*)(const void *elmt, const void *data)</type>
          <declname>eqf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Find the last element before index <emphasis>i</emphasis> in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This will return the index of the last element in the <emphasis>vector</emphasis> before index <emphasis>i</emphasis> for which the expression <computeroutput>eqf(elmt, data)</computeroutput> is <computeroutput>true</computeroutput> where <emphasis>elmt</emphasis> is the location of an element in the <emphasis>vector</emphasis>. Index <emphasis>i</emphasis> is <bold>exclusive</bold> so this will never return <emphasis>i</emphasis> itself.</para>
<para>To iterate in reverse order through all elements in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis> do: <programlisting filename=".c"><codeline><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1ga99fa8624e711c5592b80bf2a4b40952d" kindref="member">vector_find_last</ref>(vector,<sp/><ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">vector_length</ref>(vector),<sp/>eqf,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(i<sp/>&lt;<sp/>SIZE_MAX)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1ga99fa8624e711c5592b80bf2a4b40952d" kindref="member">vector_find_last</ref>(vector,<sp/>i,<sp/>eqf,<sp/>data);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If no such element is in the <emphasis>vector</emphasis> before index <emphasis>i</emphasis>, then this will return <computeroutput>SIZE_MAX</computeroutput>. Note that the largest possible index into an array of any type is <computeroutput>SIZE_MAX - 1</computeroutput> so <computeroutput>SIZE_MAX</computeroutput> is an unambiguous indication that no such element is in the <emphasis>vector</emphasis>.</para>
<para>If <emphasis>i</emphasis> is neither an index in the <emphasis>vector</emphasis> or its <ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">length</ref> then the behavior is undefined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in or just after the <emphasis>vector</emphasis> to search before </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eqf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>additional data to pass to <emphasis>eqf</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="191" column="8" bodyfile="header/vector/search.h" bodystart="191" bodyend="191"/>
        <references refid="group__vector__module_1ga49accb1745baaa317db375e67e62eb38" compoundref="header_2vector_2search_8c" startline="40" endline="51">vector_find_last_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga49accb1745baaa317db375e67e62eb38" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_find_last_z</definition>
        <argsstring>(vector_c vector, size_t i, bool(*eqf)(const void *elmt, const void *data), const void *data, size_t z)</argsstring>
        <name>vector_find_last_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>i</declname>
        </param>
        <param>
          <type>bool(*)(const void *elmt, const void *data)</type>
          <declname>eqf</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Find the last element before index <emphasis>i</emphasis> in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>This will return the index of the last element in the <emphasis>vector</emphasis> before index <emphasis>i</emphasis> for which the expression <computeroutput>eqf(elmt, data)</computeroutput> is <computeroutput>true</computeroutput> where <emphasis>elmt</emphasis> is the location of an element in the <emphasis>vector</emphasis>. Index <emphasis>i</emphasis> is <bold>exclusive</bold> so this will never return <emphasis>i</emphasis> itself.</para>
<para>To iterate in reverse order through all elements in the <emphasis>vector</emphasis> equal to <emphasis>data</emphasis> do: <programlisting filename=".c"><codeline><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1ga49accb1745baaa317db375e67e62eb38" kindref="member">vector_find_last_z</ref>(vector,<sp/><ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">vector_length</ref>(vector),<sp/>eqf,<sp/>data,<sp/>z);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(i<sp/>&lt;<sp/>SIZE_MAX)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>i<sp/>=<sp/><ref refid="group__vector__module_1ga49accb1745baaa317db375e67e62eb38" kindref="member">vector_find_last_z</ref>(vector,<sp/>i,<sp/>eqf,<sp/>data,<sp/>z);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>If no such element is in the <emphasis>vector</emphasis> before index <emphasis>i</emphasis>, then this will return <computeroutput>SIZE_MAX</computeroutput>. Note that the largest possible index into an array of any type is <computeroutput>SIZE_MAX - 1</computeroutput> so <computeroutput>SIZE_MAX</computeroutput> is an unambiguous indication that no such element is in the <emphasis>vector</emphasis>.</para>
<para>If <emphasis>i</emphasis> is neither an index in the <emphasis>vector</emphasis> or its <ref refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" kindref="member">length</ref> then the behavior is undefined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>the index in or just after the <emphasis>vector</emphasis> to search before </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>eqf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>additional data to pass to <emphasis>eqf</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of the <emphasis>vector</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="228" column="15" bodyfile="header/vector/search.c" bodystart="40" bodyend="51" declfile="header/vector/search.h" declline="228" declcolumn="15"/>
        <references refid="access_8h_1a3d34a65010e7b668473c10be6f6f72e1" compoundref="access_8h" startline="45" endline="45">vector_at</references>
        <referencedby refid="group__vector__module_1ga99fa8624e711c5592b80bf2a4b40952d" compoundref="search_8h" startline="191" endline="191">vector_find_last</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga6785d849e2623b83d30593850f88acc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_search</definition>
        <argsstring>(vector_c vector, const void *elmt, int(*cmpf)(const void *a, const void *b))</argsstring>
        <name>vector_search</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>elmt</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b)</type>
          <declname>cmpf</declname>
        </param>
        <briefdescription>
<para>Find the first element in the sorted <emphasis>vector</emphasis> equal to <emphasis>elmt</emphasis>. </para>
        </briefdescription>
        <detaileddescription>
<para>The <emphasis>vector</emphasis> must be partitioned with respect to <emphasis>elmt</emphasis> according to <emphasis>cmpf</emphasis>. That is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than <emphasis>elmt</emphasis> according to <emphasis>cmpf</emphasis>. A vector sorted by a previous call to <ref refid="group__vector__module_1ga88ac66910378df2bfbdd7bfb26020ba4" kindref="member">vector_sort()</ref> with the same <emphasis>cmpf</emphasis> satisfies these requirements.</para>
<para>The behavior is undefined if the <emphasis>vector</emphasis> is not already partitioned with respect to <emphasis>elmt</emphasis> in ascending order according to <emphasis>cmpf</emphasis>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>elmt</parametername>
</parameternamelist>
<parameterdescription>
<para>the element to search for </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmpf</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to use to determine equality </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the index of the element on success; otherwise <computeroutput>SIZE_MAX</computeroutput> </para>
</simplesect>
<simplesect kind="see"><para>vector_search_z() The equivalent operation in the explicit interface </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="260" column="8" bodyfile="header/vector/search.h" bodystart="260" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gad34720a16704a4572047cf9efb8cc990" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t vector_search_z</definition>
        <argsstring>(vector_c vector, const void *elmt, int(*cmpf)(const void *a, const void *b), size_t z)</argsstring>
        <name>vector_search_z</name>
        <param>
          <type><ref refid="common_8h_1ae2e5ca5c0f41f2b0bce39bf1b6631122" kindref="member">vector_c</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>elmt</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b)</type>
          <declname>cmpf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>z</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/search.h" line="262" column="15" bodyfile="header/vector/search.c" bodystart="53" bodyend="70" declfile="header/vector/search.h" declline="262" declcolumn="15"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="user-defined">
      <header>Sorting</header>
      <memberdef kind="function" id="group__vector__module_1ga88ac66910378df2bfbdd7bfb26020ba4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vector_sort</definition>
        <argsstring>(vector_t vector, int(*cmp)(const void *a, const void *b))</argsstring>
        <name>vector_sort</name>
        <param>
          <type><ref refid="common_8h_1a5b7d6c2eb384dea49554e889ad2740ad" kindref="member">vector_t</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b)</type>
          <declname>cmp</declname>
        </param>
        <briefdescription>
<para>Sort the <emphasis>vector</emphasis> in ascending order on a comparator. </para>
        </briefdescription>
        <detaileddescription>
<para>This isn&apos;t a stable sort: if <emphasis>cmp</emphasis> indicates that two elements are equal, their relative order in the result is unspecified.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para><parblock><para>The comparator that will be called to establish the relative order of two elements.</para>
<para>This should return a negative integer if <emphasis>a</emphasis> is less than (should come before) <emphasis>b</emphasis>, a positive integer if <emphasis>a</emphasis> is greater than (should come after) <emphasis>b</emphasis>, and zero if <emphasis>a</emphasis> and <emphasis>b</emphasis> are equal. It must return consistent results when called for the same elements, regardless of their indices in the vector.</para>
<para>This function must encode a <bold>strict total order</bold> of the elements in the <emphasis>vector</emphasis>. That is, for any elements <computeroutput>a</computeroutput>, <computeroutput>b</computeroutput>, and <computeroutput>c</computeroutput>:</para>
<para><itemizedlist>
<listitem><para><formula id="3">$a = a$</formula></para>
</listitem><listitem><para>If <formula id="4">$a = b$</formula> and <formula id="5">$b = c$</formula> then <formula id="6">$a = c$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> then <formula id="8">$b &gt; a$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> and <formula id="9">$b &lt; c$</formula> then <formula id="10">$a &lt; c$</formula> </para>
</listitem></itemizedlist>
</para>
</parblock></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/sort.h" line="45" column="6" bodyfile="header/vector/sort.h" bodystart="45" bodyend="45"/>
        <references refid="group__vector__module_1ga067d26fd8360e1460ff64a088dd87864" compoundref="header_2vector_2sort_8c" startline="16" endline="21">vector_sort_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1ga067d26fd8360e1460ff64a088dd87864" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void vector_sort_z</definition>
        <argsstring>(vector_t vector, int(*cmp)(const void *a, const void *b), size_t z)</argsstring>
        <name>vector_sort_z</name>
        <param>
          <type><ref refid="common_8h_1a5b7d6c2eb384dea49554e889ad2740ad" kindref="member">vector_t</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b)</type>
          <declname>cmp</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Sort the <emphasis>vector</emphasis> in ascending order on a comparator. </para>
        </briefdescription>
        <detaileddescription>
<para>This isn&apos;t a stable sort: if <emphasis>cmp</emphasis> indicates that two elements are equal, their relative order in the result is unspecified.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para><parblock><para>The comparator that will be called to establish the relative order of two elements.</para>
<para>This should return a negative integer if <emphasis>a</emphasis> is less than (should come before) <emphasis>b</emphasis>, a positive integer if <emphasis>a</emphasis> is greater than (should come after) <emphasis>b</emphasis>, and zero if <emphasis>a</emphasis> and <emphasis>b</emphasis> are equal. It must return consistent results when called for the same elements, regardless of their indices in the vector.</para>
<para>This function must encode a <bold>strict total order</bold> of the elements in the <emphasis>vector</emphasis>. That is, for any elements <computeroutput>a</computeroutput>, <computeroutput>b</computeroutput>, and <computeroutput>c</computeroutput>:</para>
<para><itemizedlist>
<listitem><para><formula id="3">$a = a$</formula></para>
</listitem><listitem><para>If <formula id="4">$a = b$</formula> and <formula id="5">$b = c$</formula> then <formula id="6">$a = c$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> then <formula id="8">$b &gt; a$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> and <formula id="9">$b &lt; c$</formula> then <formula id="10">$a &lt; c$</formula> </para>
</listitem></itemizedlist>
</para>
</parblock></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of the <emphasis>vector</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/sort.h" line="74" column="13" bodyfile="header/vector/sort.c" bodystart="16" bodyend="21" declfile="header/vector/sort.h" declline="74" declcolumn="13"/>
        <references refid="common_8h_1a587cb79957c36c5a87216ec27ab5fdbb" compoundref="common_8h" startline="95" endline="97">vector_length</references>
        <referencedby refid="group__vector__module_1ga88ac66910378df2bfbdd7bfb26020ba4" compoundref="sort_8h" startline="45" endline="45">vector_sort</referencedby>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gadb8a360380b1c613127e91cbff53d07b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vector_sort_with</definition>
        <argsstring>(vector_t vector, int(*cmp)(const void *a, const void *b, void *data), void *data)</argsstring>
        <name>vector_sort_with</name>
        <param>
          <type><ref refid="common_8h_1a5b7d6c2eb384dea49554e889ad2740ad" kindref="member">vector_t</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b, void *data)</type>
          <declname>cmp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
<para>Sort the <emphasis>vector</emphasis> in ascending order on a contextual comparator. </para>
        </briefdescription>
        <detaileddescription>
<para>This isn&apos;t a stable sort: if <emphasis>cmp</emphasis> indicates that two elements are equal, their relative order in the result is unspecified.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para><parblock><para>The comparator that will be called to establish the relative order of two elements.</para>
<para>This should return a negative integer if <emphasis>a</emphasis> is less than (should come before) <emphasis>b</emphasis>, a positive integer if <emphasis>a</emphasis> is greater than (should come after) <emphasis>b</emphasis>, and zero if <emphasis>a</emphasis> and <emphasis>b</emphasis> are equal. It must return consistent results when called for the same elements, regardless of their indices in the vector.</para>
<para>This function must encode a <bold>strict total order</bold> of the elements in the <emphasis>vector</emphasis>. That is, for any elements <computeroutput>a</computeroutput>, <computeroutput>b</computeroutput>, and <computeroutput>c</computeroutput>:</para>
<para><itemizedlist>
<listitem><para><formula id="3">$a = a$</formula></para>
</listitem><listitem><para>If <formula id="4">$a = b$</formula> and <formula id="5">$b = c$</formula> then <formula id="6">$a = c$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> then <formula id="8">$b &gt; a$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> and <formula id="9">$b &lt; c$</formula> then <formula id="10">$a &lt; c$</formula> </para>
</listitem></itemizedlist>
</para>
</parblock></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>contextual information to pass as the last argument to <emphasis>cmp</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/sort.h" line="111" column="6" bodyfile="header/vector/sort.h" bodystart="111" bodyend="111"/>
        <references refid="group__vector__module_1gabc2195a7f9b5a23c2d6aa1b7f17f47c6">vector_sort_with_z</references>
      </memberdef>
      <memberdef kind="function" id="group__vector__module_1gabc2195a7f9b5a23c2d6aa1b7f17f47c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void vector_sort_with_z</definition>
        <argsstring>(vector_t vector, int(*cmp)(const void *a, const void *b, void *data), void *data, size_t z)</argsstring>
        <name>vector_sort_with_z</name>
        <param>
          <type><ref refid="common_8h_1a5b7d6c2eb384dea49554e889ad2740ad" kindref="member">vector_t</ref></type>
          <declname>vector</declname>
        </param>
        <param>
          <type>int(*)(const void *a, const void *b, void *data)</type>
          <declname>cmp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>z</declname>
        </param>
        <briefdescription>
<para>Sort the <emphasis>vector</emphasis> in ascending order on a contextual comparator. </para>
        </briefdescription>
        <detaileddescription>
<para>This isn&apos;t a stable sort: if <emphasis>cmp</emphasis> indicates that two elements are equal, their relative order in the result is unspecified.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vector</parametername>
</parameternamelist>
<parameterdescription>
<para>the vector to operate on </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para><parblock><para>The comparator that will be called to establish the relative order of two elements.</para>
<para>This should return a negative integer if <emphasis>a</emphasis> is less than (should come before) <emphasis>b</emphasis>, a positive integer if <emphasis>a</emphasis> is greater than (should come after) <emphasis>b</emphasis>, and zero if <emphasis>a</emphasis> and <emphasis>b</emphasis> are equal. It must return consistent results when called for the same elements, regardless of their indices in the vector.</para>
<para>This function must encode a <bold>strict total order</bold> of the elements in the <emphasis>vector</emphasis>. That is, for any elements <computeroutput>a</computeroutput>, <computeroutput>b</computeroutput>, and <computeroutput>c</computeroutput>:</para>
<para><itemizedlist>
<listitem><para><formula id="3">$a = a$</formula></para>
</listitem><listitem><para>If <formula id="4">$a = b$</formula> and <formula id="5">$b = c$</formula> then <formula id="6">$a = c$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> then <formula id="8">$b &gt; a$</formula></para>
</listitem><listitem><para>If <formula id="7">$a &lt; b$</formula> and <formula id="9">$b &lt; c$</formula> then <formula id="10">$a &lt; c$</formula> </para>
</listitem></itemizedlist>
</para>
</parblock></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>contextual information to pass as the last argument to <emphasis>cmp</emphasis> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>z</parametername>
</parameternamelist>
<parameterdescription>
<para>the element size of the <emphasis>vector</emphasis> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="header/vector/sort.h" line="142" column="6" declfile="header/vector/sort.h" declline="142" declcolumn="6"/>
        <referencedby refid="group__vector__module_1gadb8a360380b1c613127e91cbff53d07b" compoundref="sort_8h" startline="111" endline="111">vector_sort_with</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
  </compounddef>
</doxygen>
